generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Base schema with models only (no datasource or generator)
// This file contains the shared model definitions for both SQLite and PostgreSQL

model User {
  id                 String              @id @default(cuid())
  email              String              @unique
  password           String
  firstName          String              @map("first_name")
  lastName           String              @map("last_name")
  isActive           Boolean             @default(true) @map("is_active")
  role               String              @default("USER")
  credits            Int                 @default(0)
  licenseType        String              @default("FREE") @map("license_type")
  licenseExpiry      DateTime?           @map("license_expiry")
  lastLoginAt        DateTime?           @map("last_login_at")
  resetToken         String?             @map("reset_token")
  resetTokenExpiry   DateTime?           @map("reset_token_expiry")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @updatedAt @map("updated_at")
  
  // Relations
  projects           Project[]
  creditTransactions CreditTransaction[]
  processingJobs     ProcessingJob[]
  notifications      Notification[]
  
  @@map("users")
}

model Project {
  id          String    @id @default(cuid())
  name        String
  description String?
  userId      String    @map("user_id")
  isActive    Boolean   @default(true) @map("is_active")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  
  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  videos         Video[]
  groups         VideoGroup[]
  processingJobs ProcessingJob[]
  
  @@map("projects")
}

model Video {
  id           String    @id @default(cuid())
  filename     String
  originalName String    @map("original_name")
  mimeType     String    @map("mime_type")
  size         BigInt    // BigInt works in both SQLite and PostgreSQL
  duration     Float?
  width        Int?
  height       Int?
  fps          Float?
  bitrate      Int?
  codec        String?
  hasAudio     Boolean   @default(true) @map("has_audio")
  thumbnailUrl String?   @map("thumbnail_url")
  projectId    String    @map("project_id")
  groupId      String?   @map("group_id")
  uploadedAt   DateTime  @default(now()) @map("uploaded_at")
  
  // Relations
  project Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  group   VideoGroup? @relation(fields: [groupId], references: [id], onDelete: SetNull)
  
  @@map("videos")
}

model VideoGroup {
  id          String    @id @default(cuid())
  name        String
  description String?
  projectId   String    @map("project_id")
  order       Int       @default(0)
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  
  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  videos  Video[]
  
  @@map("video_groups")
}

model ProcessingJob {
  id           String    @id @default(cuid())
  projectId    String    @map("project_id")
  userId       String    @map("user_id")
  status       String    @default("PENDING") // Using String instead of enum for compatibility
  progress     Int       @default(0)
  startedAt    DateTime? @map("started_at")
  completedAt  DateTime? @map("completed_at")
  errorMessage String?   @map("error_message")
  creditsUsed  Int       @default(0) @map("credits_used")
  outputCount  Int       @default(0) @map("output_count")
  refundedAt   DateTime? @map("refunded_at")
  createdAt    DateTime  @default(now()) @map("created_at")
  settings     String?   // JSON stored as string for compatibility
  
  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  outputs ProcessedVideo[]
  
  @@map("processing_jobs")
}

model ProcessedVideo {
  id              String        @id @default(cuid())
  jobId           String        @map("job_id")
  filename        String
  originalVideoIds String       @map("original_video_ids") // Stored as comma-separated string
  size            BigInt
  duration        Float
  width           Int
  height          Int
  fps             Float
  bitrate         Int
  settings        String        // JSON stored as string
  downloadCount   Int           @default(0) @map("download_count")
  createdAt       DateTime      @default(now()) @map("created_at")
  
  // Relations
  job ProcessingJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
  
  @@map("processed_videos")
}

model CreditTransaction {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  type        String   // PURCHASE, USAGE, REFUND, BONUS
  amount      Int
  description String
  referenceId String?  @map("reference_id")
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("credit_transactions")
}

model Notification {
  id        String    @id @default(cuid())
  userId    String    @map("user_id")
  title     String
  message   String
  type      String    @default("INFO") // INFO, SUCCESS, WARNING, ERROR
  isRead    Boolean   @default(false) @map("is_read")
  data      String?   // JSON stored as string
  createdAt DateTime  @default(now()) @map("created_at")
  readAt    DateTime? @map("read_at")
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notifications")
}